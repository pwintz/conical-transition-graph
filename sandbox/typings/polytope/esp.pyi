"""
This type stub file was generated by pyright.
"""

r"""Equality Set Projection (ESP).

Non-vertex polytope projection method from
- https://web.archive.org/web/20150103142532/
    https://www-control.eng.cam.ac.uk/~cnj22/research/projection.html
- https://infoscience.epfl.ch/record/169768

Very unstable, can not handle complex polytopes.


Reference
=========

\cite{Jones04}
"""
class Ridge:
    """A ridge.

    Attributes:

    - `E_r`: Equality set of a facet

    - `ar, br`: Affine hull of the facet
      s.t. P_{E_0} = P intersection {x | ar x = br}.
    """
    def __init__(self, E, a, b) -> None:
        ...
    


class Ridge_Facet:
    """A ridge facet.

    Attributes:

        - `E_r`: Equality set of a ridge

        - `ar,br`: Affine hull of the ridge s.t.
            P_{E_f} intersection {x | ar x = br}
            defines the ridge, where E_f is the
            equality set of the facet.

        - `E_0`: Equality set of a facet

        - `af,bf`: Affine hull of the facet.
    """
    def __init__(self, E_r, ar, br, E_0, af, bf) -> None:
        ...
    


def esp(CC, DD, bb, centered=..., abs_tol=..., verbose=...): # -> tuple[Any, Any, list[Any]] | tuple[NDArray[Any], Any | NDArray[Any], list[ndarray[_AnyShape, dtype[intp]]]] | tuple[Any | NDArray[Any], Any | NDArray[Any], list[Any]]:
    """Project polytope [C D] x <= b onto C coordinates.

    Projects the polytope [C D] x <= b onto the
    coordinates that correspond to C. The projection of the polytope
    P = {[C D]x <= b} where C is M x D and D is M x K is
    defined as proj(P) = {x in R^d | exist y in R^k s.t Cx + Dy < b}
    """
    ...

def shoot(C, D, b, maxiter=..., abs_tol=...): # -> tuple[NDArray[Any] | NDArray[intp], Any, Any]:
    """Return random equality set of P that projects on a projection facet.

    Returns randomly selected equality set E_0 of P such
    that the projection of the equality set is a facet of the projection.

    @param C: Matrix defining the polytope Cx+Dy <= b
    @param D: Matrix defining the polytope Cx+Dy <= b
    @param b: Vector defining the polytope Cx+Dy <= b

    @return: `E_0,af,bf`: Equality set and affine hull
    """
    ...

def ridge(C, D, b, E, af, bf, abs_tol=..., verbose=...): # -> list[Any]:
    """Compute all ridges of a facet in the projection.

    Input:
    `C,D,b`: Original polytope data
    `E,af,bf`: Equality set and affine hull of a facet in the projection

    Output:
    `ridge_list`: A list containing all the ridges of
        the facet as Ridge objects
    """
    ...

def adjacent(C, D, b, rid_fac, abs_tol=...): # -> tuple[NDArray[Any] | NDArray[intp], Any, Any]:
    """Compute the (unique) adjacent facet.

    @param rid_fac: A Ridge_Facet object containing the parameters for
        a facet and one of its ridges.

    @return: (E_adj,a_adj,b_adj): The equality set and parameters for
        the adjacent facet such that::

            P_{E_adj} = P intersection {x | a_adj x = b_adj}
    """
    ...

def proj_aff(Ce, De, be, expected_dim=..., abs_tol=...): # -> tuple[Any, Any]:
    """Affine projection.

    Compute the set aff = {x | Ce x + De y = be} on the form
    aff = ({x | a x = b} intersection {Ce x + De y < be}).

    Input: Polytope parameters Ce, De and be

    Output: Constants a and b
    """
    ...

def is_dual_degenerate(c, G, h, A, b, x_opt, z_opt, abs_tol=...): # -> bool:
    """Return `True` if pair of dual problems is dual degenerate.

    Checks if the pair of dual problems::

      (P): min c'x        (D): max h'z + b'y
           s.t Gx <= h         s.t G'z + A'y = c
               Ax = b                z <= 0

    is dual degenerate, i.e. if (P) has several optimal solutions.
    Optimal solutions x* and z* are required.

    Input:

    `G,h,A,b`: Parameters of (P)
    `x_opt`: One optimal solution to (P)
    `z_opt`: The optimal solution to (D) corresponding to
        _inequality constraints_ in (P)

    Output:
    `dual`: Boolean indicating whether (P) has many optimal solutions.
    """
    ...

def unique_equalityset(C, D, b, af, bf, abs_tol=..., verbose=...): # -> NDArray[Any]:
    """Return equality set E with the following property:

    P_E = {x | af x = bf} intersection P

    where P is the polytope C x + D y < b

    The inequalities have to be satisfied with equality everywhere on
    the face defined by af and bf.
    """
    ...

def unique_equalityset2(C, D, b, opt_sol, abs_tol=...): # -> NDArray[intp]:
    ...

def cheby_center(C, D, b): # -> tuple[ndarray[_AnyShape, dtype[Any]], ndarray[_AnyShape, dtype[Any]], Literal[True]] | tuple[_Array1D[float64], _Array1D[float64], Literal[False]]:
    """Calculate Chebyshev center for the polytope `C x + D y <= b`.

    Input:
    `C, D, b`: Polytope parameters

    Output:
    `x_0, y_0`: The chebyshev centra
    `boolean`: True if a point could be found, False otherwise.
    """
    ...

def normalize(AA, bb, abs_tol=...): # -> tuple[Any, Any]:
    """Normalize `A x = b` such that `A'A = 1` and `b > 0`.

    Also, remove duplicate lines.
    """
    ...

def rank(A, eps=...):
    ...

def null_space(A, eps=..., nonempty=...): # -> ndarray[_AnyShape, dtype[float64]] | ndarray[_AnyShape, dtype[Any]] | Any:
    """Returns the null space N_A to matrix A such that A N_A = 0."""
    ...

