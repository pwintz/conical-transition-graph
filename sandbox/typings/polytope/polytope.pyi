"""
This type stub file was generated by pyright.
"""

r"""Computational geometry module for polytope computations.

For linear programming the fastest installed solver is selected.
To change this choice, see the module `polytope.solvers`.

The structure of this module is based on \cite{MPT04}.
"""
from typing import Any, List, Literal, Optional, Self, Sequence
import numpy as np
from numpy.typing import NDArray

logger = ...
ABS_TOL = ...
type Matrix = NDArray[np.float64]
type Vector = NDArray[np.float64]
type VectorArray = NDArray[np.float64]
type BoolArray = NDArray[np.bool]
class Polytope:
    """A convex polytope, in half-space representation.

    The minimal vertex representation can be computed with
    the function `extreme`. A minimal half-space representation can
    be computed from a vertex representation with the function `qhull`.

    Attributes:
      - `A`: a numpy array for the hyperplane normals in hyperplane
             representation of a polytope
      - `b`: a numpy array for the hyperplane offsets in hyperplane
             representation of a polytope
      - `chebXc`: coordinates of Chebyshev center (if calculated)
      - `chebR`: Chebyshev radius (if calculated)
      - `bbox`: bounding box (if calculated)
      - `minrep`: if polytope is in minimal representation (after
                  running reduce)
      - `normalize`: if True (default), normalize given A and b arrays;
                     else, use A and b without modification.
      - `dim`: dimension
      - `volume`: volume, computed on first call

    Reference
    =========
    https://en.wikipedia.org/wiki/Convex_polytope

    See Also
    ========
    L{Region}, L{extreme}, L{qhull}
    """
    def __init__(self, 
                    A: Matrix, 
                    b: Vector, 
                    minrep: bool=False,
                    chebR: int=0,
                    # chebX=None,
                    # fulldim=None,
                    # volume=None,
                    # vertices=None,
                    # minrep      =None, 
                    # chebR       =None, 
                    # chebX       =None, 
                    # fulldim     =None, 
                    # volume      =None, 
                    # vertices    =None, 
                    normalize:bool =True, 
                ) -> None:
        ...
    
    def __str__(self) -> str:
        """Return pretty-formatted H-representation of polytope."""
        
    
    def __len__(self) -> Literal[0]:
        ...
    
    def __copy__(self) -> Self:
        ...
    
    def __contains__(self, point: Vector) -> bool:
        """Return `True` if `self` contains `point`.

        Boundary points are included.

        @param point: column vector, e.g., as `numpy.ndarray`
        @rtype: bool

        For multiple points, see the method `self.contains`.
        """
        ...
    
    def containsPoints(self, points: VectorArray, abs_tol: float) -> BoolArray:#  -> Incomplete:
        """Return Boolean array of whether each point in `self`.

        Any point that satisfies all inequalities is
        contained in `self`. A tolerance is added, and
        strict inequality checked (<). Pass `abs_tol: float=0`
        to exclude the boundary.

        @param points: column vectors
        @rtype: bool, 1d array
        """
        ...
    
    def __eq__(self, other: Any) -> bool:
        ...
    
    def __ne__(self, other: Any) -> bool:
        ...
    
    def __le__(self, other: Self) -> bool:
        ...
    
    def __ge__(self, other: Self) -> bool:
        ...
    
    def __bool__(self) -> bool:
        ...
    
    __nonzero__ = ...
    def union(self, other: Self | Region, check_convex: bool=False) -> Region:
        """Return union with Polytope or Region.

        For usage see function union.

        @type other: L{Polytope} or L{Region}
        @rtype: L{Region}
        """
        ...
    
    def diff(self, other: Self | Region) -> Region:
        """Return set difference with Polytope or Region.

        @type other: L{Polytope} or L{Region}
        @rtype: L{Region}
        """
        ...
    
    def intersect(self, other: Self | Region, abs_tol: float=...) -> Region | Self:
        """Return intersection with Polytope or Region.

        @type other: L{Polytope}.
        @rtype: L{Polytope} or L{Region}
        """
        ...
    
    def translation(self, d: Vector) -> Self:
        """Returns a copy of C{self} translated by the vector C{d}.

        Consult L{polytope.polytope._translate} for implementation details.

        @type d: 1d array
        """
        ...
    
    def rotation(self, i: int=..., j: int=..., theta:float =...) -> Self:
        """Returns a rotated copy of C{self}.

        Describe the plane of rotation and the angle of rotation (in radians)
        with i, j, and theta.

        i and j are the indices 0..N-1 of two of the identity basis
        vectors, and theta is the angle of rotation.

        Consult L{polytope.polytope._rotate} for more detail.

        @type i: int
        @type j: int
        @type theta: number
        """
        ...
    
    def copy(self) -> Self:
        """Return copy of this Polytope."""
        ...
    
    @classmethod
    def from_box(cls, intervals=...) -> Self:
        """Class method for easy construction of hyperrectangles.

        @param intervals: intervals [xi_min, xi_max],
            the cross-product of which defines the polytope
            as an N-dimensional hyperrectangle
        @type intervals: [ndim x 2] numpy array or
            list of lists::

                [[x0_min, x0_max],
                 [x1_min, x1_max],
                 ...
                 [xN_min, xN_max]]

        @return: hyperrectangle defined by C{intervals}
        @rtype: L{Polytope}
        """
        ...
    
    def project(self, dim, solver=..., abs_tol: float=..., verbose=...) -> Self | Region:
        """Return Polytope projection on selected subspace.

        For usage details see function: L{projection}.
        """
        ...
    
    def scale(self, factor) -> None:
        """Multiply polytope by scalar factor.

        A x <= b, becomes: A x <= (factor * b)

        @type factor: float
        """
        ...
    
    @property
    def dim(self) -> Any | float:
        """Return Polytope dimension."""
        ...
    
    @property
    def volume(self) -> float:
        ...
    
    @property
    def chebR(self) -> int:
        ...
    
    @property
    def chebXc(self) -> None:
        ...
    
    @property
    def cheby(self) -> tuple[Any, Any] | tuple[Any | float | Literal[0], Any | np.ndarray[Any] | None] | tuple[Literal[0], None] | tuple[float, np.ndarray[Any]]:
        ...
    
    @property
    def bounding_box(self) -> tuple[np.ndarray[float64], np.ndarray[float64]]:
        """Wrapper of L{polytope.bounding_box}.

        Computes the bounding box on first call.
        """
        ...
    
    def plot(self, ax=..., color=..., hatch=..., alpha=..., linestyle=..., linewidth=..., edgecolor=...) -> Axes | None:
        ...
    
    def text(self, txt, ax=..., color=...) -> None:
        """Plot text at Chebyshev center."""
        ...
    


def givens_rotation_matrix(i, j, theta, N) -> np.ndarray:# [np.float64]:
    """Return the Givens rotation matrix for an N-dimensional space."""

def solve_rotation_ap(u, v) -> np.ndarray[Any] | Any:
    r"""Return the rotation matrix for the rotation in the plane defined by the
    vectors u and v across TWICE the angle between u and v.

    This algorithm uses the Aguilera-Perez Algorithm \cite{Aguilera}
    to generate the rotation matrix. The algorithm works basically as follows:

    Starting with the Nth component of u, rotate u towards the (N-1)th
    component until the Nth component is zero. Continue until u is parallel to
    the 0th basis vector. Next do the same with v until it only has none zero
    components in the first two dimensions. The result will be something like
    this:

    [[u0,  0, 0 ... 0],
     [v0, v1, 0 ... 0]]

    Now it is trivial to align u with v. Apply the inverse rotations to return
    to the original orientation.

    NOTE: The precision of this method is limited by sin, cos, and arctan
    functions.
    """

class Region:
    """A polytope, possibly nonconvex.

    Represented using a `list` of convex polytopes.
    Is usable as a container of polytopes.

    Attributes:
      - `list_poly`: list of Polytope objects
      - `props`: set of propositions inside region
      - `bbox`: if calculated, bounding box of region (see bounding_box)
      - `fulldim`: if calculated, boolean indicating whether region is
                   fully dimensional
      - `dim`: dimension
      - `volume`: volume of region, calculated on first call
      - `chebXc`: coordinates of maximum Chebyshev center (if calculated)
      - `chebR`: maximum Chebyshev radius (if calculated)

    Reference
    =========
    https://en.wikipedia.org/wiki/Polytope

    See Also
    ========
    L{Polytope}
    """
    def __init__(self, list_poly=..., props=...) -> None:
        ...
    
    def __iter__(self) -> Iterator[str]:
        ...
    
    def __getitem__(self, key) -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __contains__(self, point) -> bool:
        """Return `True` if `self` contains `point`.

        See `Polytope.__contains__`.
        """
        ...
    
    def containsPoints(self, points, abs_tol: float=...) -> _Array[tuple[int], Any] | np.ndarray[Any]:
        """Return Boolean array of whether each point in `self`.

        See `Polytope.contains`.
        """
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __add__(self, other) -> Region:
        """Return union with Polytope or Region.

        Applies convex simplification if possible.
        To turn off this check,
        use Region.union

        @type other: L{Polytope} or L{Region}
        @rtype: L{Region}
        """
        ...
    
    def __bool__(self) -> bool:
        ...
    
    __nonzero__ = ...
    def union(self, other, check_convex=...) -> Region:
        """Return union with Polytope or Region.

        For usage see function union.

        @type other: L{Polytope} or L{Region}
        @rtype: L{Region}
        """
        ...
    
    def __sub__(self, other) -> Region:
        """Return set difference with Polytope or Region.

        @type other: L{Polytope} or L{Region}
        @rtype: L{Region}
        """
        ...
    
    def diff(self, other) -> Region:
        """Return set difference with Polytope or Region.

        @type other: L{Polytope} or L{Region}
        @rtype: L{Region}
        """
        ...
    
    def __and__(self, other) -> Region:
        """Return intersection with Polytope or Region.

        Absolute tolerance 1e-7 used.
        To select the absolute tolerance use
        method Region.intersect

        @type other: L{Polytope} or L{Region}
        @rtype: L{Polytope} or L{Region}
        """
        ...
    
    def intersect(self, other, abs_tol: float=...) -> Region:
        """Return intersection with Polytope or Region.

        @type other: iterable container of L{Polytope}.
        @rtype: L{Region}
        """
        ...
    
    def rotation(self, i=..., j=..., theta=...) -> Region:
        """Returns a rotated copy of C{self}.

        Describe the plane of rotation and the angle of rotation (in radians)
        with i, j, and theta.

        i and j are the indices 0..N-1 of two of the identity basis
        vectors, and theta is the angle of rotation.

        Consult L{polytope.polytope._rotate} for more detail.

        @type i: int
        @type j: int
        @type theta: number
        """
        ...
    
    def translation(self, d) -> Region:
        """Returns a copy of C{self} translated by the vector C{d}.

        Consult L{polytope.polytope._translate} for implementation details.

        @type d: 1d array
        """
        ...
    
    def __copy__(self) -> Region:
        """Return copy of this Region."""
        ...
    
    def copy(self) -> Region:
        """Return copy of this Region."""
        ...
    
    @property
    def dim(self) -> Any:
        """Return Region dimension."""
        ...
    
    @property
    def volume(self) -> float:
        ...
    
    @property
    def chebR(self) -> None:
        ...
    
    @property
    def chebXc(self) -> None:
        ...
    
    @property
    def cheby(self) -> tuple[Any, Any] | tuple[Any | float | Literal[0], Any | np.ndarray[Any] | None] | tuple[Literal[0], None] | tuple[float, np.ndarray[Any]]:
        ...
    
    @property
    def bounding_box(self) -> tuple[Vector, Vector]:
        """Wrapper of polytope.bounding_box.

        Computes the bounding box on first call.
        """
        ...
    
    def plot(self, ax=..., color=..., hatch=..., alpha=..., linestyle=..., linewidth=..., edgecolor=...): # -> Axes | None:
        """Plot a `polytope` on axes `ax`."""
        ...
    
    def text(self, txt, ax=..., color=...) -> None:
        """Plot text at Chebyshev center."""
        ...
    


def is_empty(polyreg: Polytope | Region) -> bool:
    """Check if the description of a polytope is empty

    @param polyreg: L{Polytope} or L{Region} instance

    @return: Boolean indicating whether polyreg is empty
    """

def is_fulldim(polyreg: Polytope | Region, abs_tol: float=...) -> np.bool | bool:
    """Check if a polytope or region has inner points.

    @param polyreg: L{Polytope} or L{Region} instance

    @return: Boolean that is True if inner points found, False
        otherwise.
    """

def is_convex(reg: Region, abs_tol: float=...) -> tuple[Literal[False], None] | tuple[Literal[True], Region | Polytope | Any] | Literal[True]:
    """Check if a region is convex.

    @type reg: L{Region}

    @return: result,envelope: result indicating if convex. if found to
        be convex the envelope describing the convex polytope is
        returned.
    """

def is_inside(polyreg: Polytope | Region, point: Sequence[Vector] | Vector, abs_tol: float=...) -> bool:
    """Return `point in polyreg`.

    @type point: `collections.abc.Sequence` or `numpy.ndarray`
    @rtype: bool
    """

def is_subset(small: Polytope | Region, big: Polytope | Region, abs_tol: float=...) -> bool:
    r"""Return True if small \subseteq big.

    @type small: L{Polytope} or L{Region}
    @type big:   L{Polytope} or L{Region}

    @rtype: bool
    """

def reduce(poly: Polytope | Region, nonEmptyBounded=..., abs_tol: float=...) -> Region | Polytope:
    """Remove redundant inequalities from the hyperplane representation.

    Uses the algorithm described at [1],
    by solving one LP for each facet.

    [1] https://www.cs.mcgill.ca/~fukuda/soft/polyfaq/node24.html

    Warning:
      - nonEmptyBounded == 0 case is not tested much.

    @type poly: L{Polytope} or L{Region}

    @return: Reduced L{Polytope} or L{Region} object
    """

def union(polyreg1: Region, polyreg2: Region, check_convex: bool=...) -> Region:
    """Compute the union of polytopes or regions

    @type polyreg1: L{Polytope} or L{Region}
    @type polyreg2: L{Polytope} or L{Region}
    @param check_convex: if True, look for convex unions and simplify

    @return: region of non-overlapping polytopes describing the union
    """

def cheby_ball(poly1: Polytope) -> tuple[Any, Any] | tuple[Any | float | Literal[0], Any | np.ndarray[Any] | None] | tuple[Literal[0], None] | tuple[float, np.ndarray[Any]]:
    """Calculate Chebyshev radius and center for a polytope.

    The Chebyshev radius is defined here as the radius of a maximal
    inscribed ball of the given polytope. The center of a maximal ball
    is also returned, but note that unlike the radius, it is not
    necessarily unique. If input is a region, then a largest Chebyshev
    ball is returned.

    N.B., this function will return whatever it finds in attributes
    chebR and chbXc if not None, without (re)computing the Chebyshev ball.

    Example (low dimension):

    r1,x1 = cheby_ball(P) calculates the center and half the
    length of the longest line segment along the first coordinate axis
    inside polytope P

    @type poly1: L{Polytope} or L{Region}

    @return: rc,xc: Chebyshev radius rc (float) and center xc (numpy array)
    """

def bounding_box(polyreg: Polytope | Region) -> tuple[Vector, Vector]:
    """Return smallest hyperbox containing polytope or region.

    If polyreg.bbox is not None,
    then it is returned without update.

    @type polyreg: L{Polytope} or L{Region}

    @return: (l, u) where:

        - l = [x1min,
               x2min,
               ...
               xNmin]

        - u = [x1max,
               x2max,
               ...
               xNmax]

    @rtype:
        - l = 2d array
        - u = 2d array
    """

def envelope(reg: Region, abs_tol: float=...) -> Region | Polytope:
    """Compute envelope of a region.

    The envelope is the polytope defined by all "outer" inequalities a
    x < b such that {x | a x < b} intersection P = P for all polytopes
    P in the region. In other words we want to find all "outer"
    equalities of the region.

    If envelope can't be computed an empty polytope is returned

    @type reg: L{Region}
    @param abs_tol: Absolute tolerance for calculations

    @return: Envelope of input
    """

count = ...
def mldivide(a, b, save=...) -> Region:
    r"""Return set difference a \ b.

    @param a: L{Polytope} or L{Region}
    @param b: L{Polytope} to subtract

    @return: L{Region} describing the set difference
    """

def intersect(poly1: Polytope | Region, poly2: Polytope | Region, abs_tol: float=...) -> Region | Polytope:
    """Compute the intersection between two polytopes or regions

    @type poly1: L{Polytope} or L{Region}
    @type poly2: L{Polytope} or L{Region}

    @return: Intersection of poly1 and poly2 described by a polytope
    """

def volume(polyreg: Polytope | Region, nsamples=..., seed=...) -> float:
    """Approximately compute the volume of a Polytope or Region.

    A randomized algorithm is used.

    @type polyreg: L{Polytope} or L{Region}
    @param nsamples: number of samples to generate to
        use for estimating volume
    @type nsamples: positive integer
    @param seed: initialization for the random number
        generator. Passed as argument to the parameter
        `seed` of the function `numpy.random.default_rng`,
        read the docstring of that function for details.

        The seed can be used for reproducible volume
        computations. The documentation of the class
        `numpy.random.SeedSequence` includes useful
        recommendations for how to initialize a random
        generator automatically, and record the seed
        for reusing it.

    @return: Volume of input
    """

def extreme(poly1: Polytope): # -> ndarray[tuple[int, int], dtype[Any]] | ndarray[tuple[int, int], dtype[float64]] | None:
    """Compute the extreme points of a _bounded_ polytope

    @param poly1: Polytope in dimension d

    @return: A (N x d) numpy array containing the N vertices of poly1
    """

def qhull(vertices: VectorArray, abs_tol: float=...) -> Polytope:
    """Use quickhull to compute a convex hull.

    @param vertices: A N x d array containing N vertices in dimension d

    @return: L{Polytope} describing the convex hull
    """

def projection(poly1: Polytope, dim, solver=..., abs_tol: float=..., verbose=...) -> Polytope | Region:
    """Projects a polytope onto lower dimensions.

    Available solvers are:

      - "esp": Equality Set Projection;
      - "exthull": vertex projection;
      - "fm": Fourier-Motzkin projection;
      - "iterhull": iterative hull method.

    Example:
    To project the polytope `P` onto the first three dimensions, use
        >>> P_proj = projection(P, [1,2,3])

    @param poly1: Polytope to project
    @param dim: Dimensions on which to project
    @param solver: A solver can be specified, if left blank an attempt
        is made to choose the most suitable solver.
    @param verbose: if positive, print solver used in case of
        guessing; default is 0 (be silent).

    @rtype: L{Polytope}
    @return: Projected polytope in lower dimension
    """

def separate(reg1: Region, abs_tol: float=...) -> list[Any]:
    """Divide a region into several regions such that they are
    all connected.

    @type reg1: L{Region}
    @param abs_tol: Absolute tolerance

    @return: List [] of connected Regions
    """

def is_adjacent(poly1: Polytope | Region, poly2: Polytope | Region, overlap=..., abs_tol: float=...) -> np.bool | bool:
    """Return True if two polytopes or regions are adjacent.

    Check by enlarging both slightly and checking for intersection.

    @type poly1, poly2: L{Polytope}s or L{Region}s

    @param overlap: return True if polytopes are neighbors OR overlap

    @param abs_tol: absolute tolerance

    @return: True if polytopes are adjacent
    """

def is_interior(r0: Polytope | Region, r1: Polytope | Region, abs_tol: float=...) -> bool:
    """Return True if r1 is strictly in the interior of r0.

    Checks if r1 enlarged by abs_tol
    is a subset of r0.

    @type r0: L{Polytope} or L{Region}
    @type r1: L{Polytope} or L{Region}

    @rtype: bool
    """

def projection_fm(poly1: Polytope, new_dim, del_dim, abs_tol: float=...) -> Polytope | Region:
    """Help function implementing Fourier Motzkin projection.

    Should work well for eliminating few dimensions.
    """

def projection_exthull(poly1: Polytope, new_dim) -> Polytope | Region:
    """Help function implementing vertex projection.

    Efficient in low dimensions.
    """

def projection_iterhull(poly1: Polytope, new_dim, max_iter=..., verbose=..., abs_tol: float=...):
    """Helper function implementing the "iterative hull" method.

    Works best when projecting _to_ lower dimensions.
    """

def projection_esp(poly1: Polytope, keep_dim, del_dim) -> Polytope:
    """Helper function implementing "Equality set projection".

    CAUTION: Very buggy.
    """

def region_diff(poly: Polytope, reg: Region, abs_tol: float=..., intersect_tol: float=..., save=...):
    """Subtract a region from a polytope

    @param poly: polytope from which to subtract a region
    @param reg: region which should be subtracted
    @param abs_tol: absolute tolerance

    @return: polytope or region containing non-overlapping polytopes
    """

def num_bin(N: int, places: int=...) -> list[Any]:
    """Return N as list of bits, zero-filled to places.

    E.g., given N=7, num_bin returns [1, 1, 1, 0, 0, 0, 0, 0].
    """

def box2poly(box) -> Polytope:
    """Return new Polytope from box.

    @param box: defining the Polytope
    @type box: [[x1min, x1max], [x2min, x2max],...]
    """

def enumerate_integral_points(poly: Polytope | Region):#  -> ndarray[_AnyShape, dtype[Any]]:
    """Return all points in `poly` that have integer coordinates.

    @param poly: polytope
    @type poly: `polytope.polytope.Region` or
        `polytope.polytope.Polytope`
    @return: coordinates of `m` points as `d X m` array,
        where `d` the dimension
    @rtype: `numpy.ndarray`
    """

def grid_region(polyreg: Polytope | Region, res: int=...):# -> tuple[ndarray[_AnyShape, dtype[Any]], list[Any] | Any]:
    """Return bounding box grid points within `polyreg`.

    @type polyreg: L{Polytope} or L{Region}
    @param res: resolution of grid, i.e., how many points
        the grid has per dimension, before filtering based
        on which points are contained in the 
    @type res: `list` of `int` >= 1,
        with `len` equal to `polyreg.dim`
    """

def simplices2polytopes(points: NDArray[np.float64], triangles: NDArray[np.float64]) -> list[Any]:
    """Convert a simplicial mesh to polytope H-representation.

    @type points: N x d
    @type triangles: NT x 3

    References
    ==========
    https://en.wikipedia.org/wiki/Simplex
    https://en.wikipedia.org/wiki/Triangle_mesh
    """

